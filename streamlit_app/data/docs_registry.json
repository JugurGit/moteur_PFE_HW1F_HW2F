{
  "ir/models/hw1f.py": {
    "title": "Hull–White 1F — modèle analytique + Monte Carlo",
    "tags": ["HW1F", "model", "rates"],
    "summary": "- **Rôle** : implémente les formules analytiques du modèle de Hull–White 1 facteur et une couche de simulation (directe / MC).\n- **Utilisation dans le projet** : alimenter les pricers HW1F (swaption/caplet) et les modules risques (EPE/PFE) via une courbe initiale et des paramètres (a, sigma, r0).\n- **Objets clés** :\n  - `HullWhiteModel` : formules (A(t,T), B(t,T), alpha(t), short_rate)\n  - `HullWhiteSimulation` : génération de r(T) / utilitaires MC\n  - `HullWhiteCurveBuilder` : façade qui agrège `model + sim` et expose `zero_coupon_bond`, etc.",
    "usage": "```python\nfrom ir.market.curve import Curve\nfrom ir.models.hw1f import HullWhiteCurveBuilder\n\ncurve = Curve(time, dfs, smooth=1e-7)\nbuilder = HullWhiteCurveBuilder(curve, params={\"a\":0.03,\"sigma\":0.01}, n_paths=20000, seed=2025)\n\n# Distribution de P(t,T)\nP = builder.zero_coupon_bond(t=1.0, T=5.0)\n```"  },
  
    "ir/models/hw2f.py": {
    "title": "Hull–White 2F (G2++) — blocs analytiques (caplets + swaptions)",
    "tags": ["HW2F", "G2++", "model", "rates", "analytics"],
    "summary": "- **Rôle** : implémente le modèle Hull–White 2 facteurs (G2++) *sans simulation*, en fournissant les briques analytiques fermées nécessaires au pricing.\n- **Utilisation dans le projet** :\n  - **Caplets** : via la variance fermée `v2_caplet(T,S)` utilisée dans la représentation option sur ZC-bond.\n  - **Swaptions** : via les intégrales fermées `I_aa`, `I_bb`, `I_ab` utilisées par l’approximation gaussienne du taux de swap (calibration HW2F “profile” et pricing).\n- **Objets clés** :\n  - `HullWhite2FModel` : interface courbe (discount/forward) + loadings `B_a`, `B_b` + ingrédients analytiques.\n  - `v2_caplet(T,S)` : variance de l’option sur ZC bond (caplet).\n  - `I_aa(T,U,V,a)`, `I_bb(T,U,V,b)`, `I_ab(T,U,V,a,b)` : intégrales fermées entrant dans la variance du swap rate approché.",
    "usage": "```python\nfrom ir.market.curve import Curve\nfrom ir.models.hw2f import HullWhite2FModel\n\ncurve = Curve(time, dfs, smooth=1e-7)\nmodel = HullWhite2FModel(curve, parameters={\"a\":0.10,\"b\":0.02,\"rho\":-0.30,\"sigma\":0.01,\"eta\":0.008})\n\n# Caplet ingredient : variance v^2(T,S)\nv2 = model.v2_caplet(T=1.0, S=1.5)\n\n# Swaption ingredient : intégrales fermées\nIaa = model.I_aa(T=1.0, U=5.0, V=7.0, a=model.parameters[\"a\"])\nIbb = model.I_bb(T=1.0, U=5.0, V=7.0, b=model.parameters[\"b\"])\nIab = model.I_ab(T=1.0, U=5.0, V=7.0, a=model.parameters[\"a\"], b=model.parameters[\"b\"])\n```"  }, 
  
    "ir/pricers/hw1f_pricer.py": {
  "title": "Hull–White 1F — pricer (cap/floor, swap, swaption, bond options)",
  "tags": ["HW1F", "pricer", "rates", "Jamshidian", "analytics"],
  "summary": "- **Rôle** : moteur de pricing sous Hull–White 1 facteur, construit autour d’un `HullWhiteCurveBuilder` (courbe + modèle + simulation).\n- **Utilisation dans le projet** :\n  - Pricing *analytique* d’options sur ZC bond, caplets/caps/floors.\n  - Pricing *analytique via décomposition de Jamshidian* pour swaptions et options sur obligations couponnées.\n  - Sert de brique centrale pour la **calibration HW1F** (comparaison prix modèle vs marché) et pour les modules risques (EPE/PFE) via `curve_sim`.\n- **Objets / méthodes clés** :\n  - `zero_bond_call/put(T,S,K)` : options européennes sur ZC bond en fermé.\n  - `caplet(T1,T2,N,K)` + `cap(Tau,N,K)` + `floor(Tau,N,K)` : cap/floor par agrégation de (cap/floor)lets.\n  - `swap(Tau,N,K,payer)` : PV swap vanilla (jambe float vs fixe) sur la courbe initiale.\n  - `swaption(Tau,N,K,payer)` : swaption européenne via **Jamshidian** (root `r*` + somme d’options ZC).\n  - `bond_option(T,Tau,C,K,N,call)` : option sur obligation couponnée via **Jamshidian** (`_find_rstar_bond`).",
  "usage": "```python\nfrom ir.market.curve import Curve\nfrom ir.pricers.hw1f_pricer import HullWhitePricer\n\ncurve = Curve(time, dfs, smooth=1e-7)\npricer = HullWhitePricer(curve, n_paths=20000, n_steps=252, seed=2025, hw_params={\"a\":0.03,\"sigma\":0.01})\n\n# Swaption payer (expiry=1Y, maturité=6Y, paiements annuels)\nTau = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\nprice_swpn = pricer.swaption(Tau=Tau, N=1e6, K=0.03, payer=True)\n\n# Cap (caplets) sur mêmes dates\nprice_cap = pricer.cap(Tau=Tau, N=1e6, K=0.03)\n```"  }, 
  
  "ir/pricers/hw2f_pricer.py": {
  "title": "Hull–White 2F (G2++) — pricer (caplet via bond option, swaption via approx gaussienne)",
  "tags": ["HW2F", "G2++", "pricer", "rates", "Bachelier", "Gaussian-approx"],
  "summary": "- **Rôle** : moteur de pricing sous Hull–White 2 facteurs (G2++), orienté *caplets* et *swaptions*.\n- **Utilisation dans le projet** :\n  - Base de pricing utilisée lors de la **calibration HW2F** (profile calibration : grille sur (a,b,rho) puis inner sur (sigma,eta)).\n  - Sert aussi au pricing “quick” des swaptions en **approximation gaussienne** (swap-rate approx) et au pricing caplets via représentation en option sur ZC bond.\n- **Approches de pricing** :\n  - `caplet_hw2f(T1,T2,N,K)` : **caplet** via put sur ZC bond (formule fermée) ; dépend de `v2_caplet(T,S)` du modèle.\n  - `swaption_approx_hw2f(Tau,N,K,payer)` : **swaption** via *frozen weights* + intégrales fermées `I_aa/I_bb/I_ab` + pricing **Bachelier** sur le taux de swap.\n- **Objets / méthodes clés** :\n  - `zero_bond_put_hw2f` / `zero_bond_call_hw2f` : options ZC bond en fermé (via variance `v^2(T,S)` G2++).\n  - `_annuity_and_swap_rate_0` : calcule (A0, S0) depuis la courbe.\n  - `_swaption_weights_frozen` : construit les poids gelés `c_j` sur les dates `U_j` pour l’approx swap-rate.",
  "usage": "```python\nfrom ir.market.curve import Curve\nfrom ir.pricers.hw2f_pricer import HullWhite2FPricer\n\ncurve = Curve(time, dfs, smooth=1e-7)\npricer = HullWhite2FPricer(curve, hw2f_params={\n    \"a\":0.10, \"b\":0.02, \"rho\":-0.30, \"sigma\":0.01, \"eta\":0.008\n})\n\n# Caplet (fixing 1Y, paiement 1.5Y)\ncaplet = pricer.caplet_hw2f(T1=1.0, T2=1.5, N=1e6, K=0.03)\n\n# Swaption payer (expiry=1Y, maturité=6Y, paiements annuels)\nTau = [1.0, 2.0, 3.0, 4.0, 5.0, 6.0]\nswpn = pricer.swaption_approx_hw2f(Tau=Tau, N=1e6, K=0.03, payer=True)\n```",
  "notes": "- **Convention** : ce pricer est en *single-curve* (discounting = forwarding) et utilise `Delta = Tau[i]-Tau[i-1]`.\n- `swaption_approx_hw2f` : méthode **approx** (frozen weights + swap-rate gaussien). Très rapide et pratique pour calibration, mais ce n’est pas le pricing exact G2++ Jamshidian-like."
  }, 
  "ir/calibration/hw1f_calibration.py": {
  "title": "Hull–White 1F — calibrateur (a, sigma) sur caplets ou swaptions (RMSRE + hook Streamlit)",
  "tags": ["HW1F", "calibration", "optimizer", "L-BFGS-B", "Nelder-Mead", "Streamlit"],
  "summary": "- **Rôle** : calibres les paramètres **(a, sigma)** du modèle Hull–White 1 facteur à partir de prix de marché (caplets ou swaptions).\n- **Principe** :\n  - Paramétrisation en **log** pour imposer la positivité : `a = exp(x0)`, `sigma = exp(x1)`.\n  - Fonction objectif = **RMSRE** (*root mean squared relative error*) sur les prix (ou sur **forward premium** pour les swaptions).\n  - Impression d’un suivi itératif + rapport final par instrument.\n- **Entrées attendues** (`market_prices`) : dict avec au minimum `Prices`, `Strike`, `Notional` et :\n  - si `Caplets` : `Expiry`, `Maturity`\n  - si `Swaptions` : `Dates` (scheduling `[T0, ..., Tn]`)\n- **Intégration Streamlit** :\n  - `progress_cb` (optionnel) appelé à chaque itération de l’optimiseur via `callback()`.\n  - Permet d’afficher en live `iter, a, sigma, rmsre` dans l’UI (page calibration).",
  "usage": "```python\nfrom ir.pricers.hw1f_pricer import HullWhitePricer\nfrom ir.calibration.hw1f_calibration import HullWhiteCalibrator\n\npricer = HullWhitePricer(curve, n_paths=20000, seed=2025)\n\n# Exemple: calibration Swaptions (market dict construit depuis ton template)\ncal = HullWhiteCalibrator(\n    pricer,\n    market_prices=mkt_dict,\n    calibrate_to=\"Swaptions\",\n)\n\nres = cal.calibrate(init_a=0.01, init_sigma=0.01, method=\"L-BFGS-B\")\nprint(pricer.model.parameters)  # a, sigma mis à jour\n```"  }, 
  
  "ir/calibration/hw2f_profile.py": {
  "title": "Hull–White 2F (G2++) — calibration sur swaptions (grille (a,b,rho) + optim (sigma,eta)",
  "tags": ["HW2F", "G2++", "calibration", "profile", "swaption", "Bachelier", "optimizer", "Streamlit"],
  "summary": "- **Rôle** : calibre le modèle **Hull–White 2 facteurs (G2++)** sur un set de **swaptions** via une calibration *profile* :\n  - **Outer loop (grille)** : exploration de `(a, b, rho)`\n  - **Inner loop (optim)** : calibration de `(sigma, eta)` pour chaque triplet outer\n- **Pricing utilisé** : approximation **Gaussian swap-rate** (poids figés) + pricing **Bachelier** sur le swap rate.\n- **Objectif** : minimiser la **RMSRE** (*root mean squared relative error*) entre prix modèle et prix marché.\n- **Convention swaptions** :\n  - `use_forward_premium=True` compare `PV / DF(T0)` (forward premium) au marché — cohérent avec ton calibrateur 1F.\n  - `use_forward_premium=False` compare le PV directement.\n- **Optimisation** : paramètres positifs via log-paramétrisation dans l’inner loop (`sigma = exp(x0)`, `eta = exp(x1)`), méthode typique `L-BFGS-B`.`",
  "usage": "```python\nfrom ir.pricers.hw2f_pricer import HullWhite2FPricer\nfrom ir.calibration.hw2f_profile import HullWhite2FProfileCalibrator\n\npricer = HullWhite2FPricer(curve)\n\n# market_prices (dict) typique: Prices, Strike(%), Notional, Dates([T0,...,Tn])\ncal = HullWhite2FProfileCalibrator(\n    pricer,\n    market_prices=mkt_dict,\n    use_forward_premium=True,\n)\n\nres = cal.calibrate_profile(\n    grid_a=[0.01, 0.02, 0.05],\n    grid_b=[0.003, 0.01, 0.02],\n    grid_rho=[-0.5, -0.2, 0.0],\n    init_sigma=0.01,\n    init_eta=0.008,\n    inner_method=\"L-BFGS-B\",\n    top_k=3,\n)\n\nbest = res[\"best\"]\nprint(best[\"a\"], best[\"b\"], best[\"rho\"], best[\"sigma\"], best[\"eta\"], best[\"rmsre\"])\n```"  }, 
  
  "ir/calibration/vol.py": {
  "title": "Volatilité implicite Bachelier — inversion prix → vol normale (bps) via Brent",
  "tags": ["vol", "Bachelier", "normal vol", "implied vol", "root finding", "calibration"],
  "summary": "- **Rôle** : fournit une fonction utilitaire `black_normal_vol` qui calcule la **volatilité implicite normale (Bachelier)** à partir d’un **prix** (swaption/caplet), d’un **forward**, d’un **strike**, d’une **maturité**, d’un **notional** et d’une **annuity**.\n- **Méthode** : inversion numérique par **recherche de racine (Brent / `brentq`)** sur l’équation `Price_model(sigma) - Price_mkt = 0`.\n- **Conventions d’unités** :\n  - `forward` et `strike` sont attendus en **%** et convertis en **taux** via `/100`.\n  - la vol retournée est en **bps** (`sigma * 10000`).\n- **Formule prix (Bachelier)** :\n  - Prix = `annuity * notional * ((F-K) N(d) + sigma * sqrt(T) * n(d))` avec `d = (F-K)/(sigma*sqrt(T))`.",
  "usage": "```python\nfrom ir.calibration.vol import black_normal_vol\n\n# Exemple: swaption priced en forward premium ou PV selon ton annuity/notional\nprice = 12500.0\nforward_pct = 2.10   # %\nstrike_pct  = 2.00   # %\nT = 1.0              # 1Y\nnotional = 1e6\nannuity = 4.25       # ex: A0/DF(T0) si tu veux coller au forward premium\n\nvol_bps = black_normal_vol(price, forward_pct, strike_pct, T, notional, annuity)\nprint(vol_bps)\n```"  }, 
  
  "ir/risk/hw2f_sim.py": {
  "title": "HW2F (G2++) — simulateur Monte Carlo de P(t,T) (distribution ZC bonds)",
  "tags": ["HW2F", "G2++", "simulation", "Monte Carlo", "curve_sim", "zero-coupon"],
  "summary": "- **Rôle** : fournit une classe `HW2FCurveSim` qui génère des **distributions Monte Carlo** de **zéro-coupons** `P(t,T)` sous Hull–White 2 facteurs (G2++), pour être utilisée comme un équivalent de `curve_sim` (comme en HW1F).\n- **Objectif dans le projet** : alimenter les modules risque (PFE/EPE) et les pricers/simulations en produisant `P(t,T)` sur un grand nombre de scénarios.\n- **Approche** :\n  - simule exactement `(x_t, y_t)` gaussiens corrélés (facteurs OU sous Q)\n  - reconstruit `P(t,T)` via la forme affine : `P(t,T)=P(0,T)/P(0,t)*exp(-B_a x_t - B_b y_t - 0.5 v^2(t,T))`\n  - `v^2(t,T)` est pris via `model.v2_caplet(expiry=t, maturity=T)` (choix cohérent avec ton notebook).\n- **Fonctions clés** :\n  - `_simulate_xy(t)` : tirage exact joint de `(x_t,y_t)` avec corrélation `rho`\n  - `zero_coupon_bond(t,T)` : retourne `ndarray (n_paths,)` des `P(t,T)` simulés.",
  "usage": "```python\nfrom ir.risk.hw2f_sim import HW2FCurveSim\nfrom ir.models.hw2f import HullWhite2FModel\n\nmodel = HullWhite2FModel(curve, parameters={\"a\":0.10,\"b\":0.02,\"rho\":-0.30,\"sigma\":0.01,\"eta\":0.008})\ncurve_sim = HW2FCurveSim(curve=curve, model=model, n_paths=20000, seed=2025, use_legacy_global_seed=False)\n\n# Distribution de P(t,T)\nP_1y_5y = curve_sim.zero_coupon_bond(t=1.0, T=5.0)\nprint(P_1y_5y.mean(), P_1y_5y.std())\n```"  }, 
  
  "ir/risk/pfe_plot.py": {
  "title": "PFE/EPE — helpers de plotting (matplotlib) pour profils d’exposition",
  "tags": ["PFE", "EPE", "plot", "matplotlib", "risk", "reporting"],
  "summary": "- **Rôle** : centralise une fonction de visualisation propre et réutilisable pour afficher un **profil PFE** (quantile) et optionnellement **EPE** sur une grille de temps.\n- **Objectif dans le projet** : fournir des figures cohérentes (style/format) pour les pages Streamlit (PFE Swap, portfolio tracking, reporting) et pour les notebooks.\n- **Fonctions clés** :\n  - `_human_money(x)` : formate les montants en unités lisibles (`k`, `M`, `B`) pour l’axe Y.\n  - `plot_pfe_profile(grid, pfe, epe=None, q=..., ...)` : trace PFE (+ EPE optionnel), remplit sous la courbe, annote le pic, et permet d’exporter en PNG.",
  "usage": "```python\nfrom ir.risk.pfe_plot import plot_pfe_profile\n\nfig, ax = plot_pfe_profile(\n    grid=grid,\n    pfe=pfe_95,\n    epe=epe,\n    q=0.95,\n    title=\"PFE Swap — HW2F\",\n    subtitle=\"N=100m | K=3.0% | payer | 20k paths\",\n    savepath=None,\n)\n\n# En Streamlit:\n# st.pyplot(fig, clear_figure=True)\n```"  }, 
    
  "ir/risk/pfe_swap.py": {
    "title": "PFE/EPE Swap — calcul d’exposition d’un IRS vanilla via simulateur de courbe (HW1F/HW2F)",
    "tags": ["PFE", "EPE", "swap", "exposure", "Monte Carlo", "HW1F", "HW2F", "risk"],
    "summary": "- **Rôle** : calcule la **distribution de MTM** d’un swap vanilla à des dates `t` (via des ZC simulés), puis agrège en **PFE(q)** et **EPE** sur une grille.\n- **Compatibilité** : fonctionne avec tout simulateur exposant `zero_coupon_bond(t, T) -> ndarray`.\n  - **HW1F** : `HullWhiteCurveBuilder` (via `curve_sim.zero_coupon_bond` et `curve_sim.sim.n_paths`)\n  - **HW2F** : `HW2FCurveSim` (via `curve_sim.zero_coupon_bond` et `curve_sim.n_paths`)\n- **Fonctions clés** :\n  - `_get_n_paths(curve_sim)` : récupère `n_paths` de façon robuste (2F direct ou 1F via `sim`).\n  - `swap_mtm_distribution_at_t(...)` : construit la distribution de **V(t)** pour un swap (payer/receiver) en utilisant :\n    - jambe flottante : `P(t,T0) - P(t,Tm)`\n    - jambe fixe : `K * ∑ Δ_i P(t,Ti)`\n    - MTM : `N * w * (float_leg - fixed_leg)` avec `w=+1` payer, `w=-1` receiver\n  - `pfe_profile_swap(...)` : boucle sur la grille `grid`, calcule **E(t)=max(V(t),0)** et retourne :\n    - `PFE_q(t)=quantile(E(t), q)`\n    - `EPE(t)=mean(E(t))`",
    "usage": "```python\nimport numpy as np\nfrom ir.risk.pfe_swap import pfe_profile_swap\n\n# curve_sim: HW1F curve_sim (HullWhiteCurveBuilder) ou HW2F (HW2FCurveSim)\nTau = [1.0, 1.5, 2.0, 2.5, 3.0]\ngrid = np.linspace(0.0, 3.0, 31)\n\npfe, epe = pfe_profile_swap(\n    curve_sim=curve_sim,\n    grid=grid,\n    Tau=Tau,\n    K=0.03,\n    N=100e6,\n    payer=True,\n    q=0.95,\n)\n```"    }, 
  
    "ir/instruments/rates.py": {
  "title": "Rates instruments — wrappers POO qui délèguent aux pricers HW1F/HW2F",
  "tags": ["instruments", "rates", "HW1F", "HW2F", "pricing", "portfolio"],
  "summary": "- **Rôle** : définit des objets “instrument” (Caplet/Cap/Floor/Swap/Swaption…) avec une API commune `price(pricer)`.\n- **Philosophie** : *zéro formule recodée* → ces classes **délèguent** au pricer disponible (HW1F ou HW2F) en détectant les méthodes (`hasattr`).\n- **But dans le projet** :\n  - uniformiser le pricing dans l’UI ou plus tard dans des portfolios (`list[Instrument]`),\n  - garder l’existant (pricers/calibrators) tel quel, tout en apportant une couche POO “propre”.\n- **Objets clés** :\n  - `Caplet` : appelle `pricer.caplet(...)` (HW1F) ou `pricer.caplet_hw2f(...)` (HW2F).\n  - `Floorlet` : fallback sur `pricer.floor([T1,T2],...)` si pas de `floorlet_hw2f`.\n  - `Cap` / `Floor` : appellent `cap(...)` / `floor(...)` et basculent vers `*_hw2f` si un jour tu les ajoutes.\n  - `Swap` : wrapper direct vers `pricer.swap(...)`.\n  - `Swaption` :\n    - HW2F : `swaption_approx_hw2f(...)` puis option `forward_premium` (= `PV/DF(T0)`)\n    - HW1F : `swaption(...)` puis option `forward_premium` identique.",
  "usage": "```python\nfrom ir.instruments.rates import Caplet, Swap, Swaption\n\n# --- Pricing homogène, quel que soit le pricer ---\ninst1 = Caplet(T1=1.0, T2=1.5, N=1e6, K=0.03)\npx1 = inst1.price(pricer_1f)   # -> pricer.caplet\npx2 = inst1.price(pricer_2f)   # -> pricer.caplet_hw2f (si disponible)\n\nswap = Swap(Tau=[0.0, 1.0, 2.0, 3.0], N=1e6, K=0.028, payer=True)\npv_swap = swap.price(pricer_1f)\n\nswpn = Swaption(Tau=[1.0, 1.5, 2.0, 2.5, 3.0], N=1e6, K=0.03, payer=True, forward_premium=True)\nfp = swpn.price(pricer_2f)     # -> approx HW2F + /DF(T0)\n```"}


}
